
outfile = args[2];
infile = args[3];

word = "[a-zA-Z0-9\[\]_]+";
equals = "=";
comma = ",";
open_paren = "\(";
close_paren = "\)";
open_brace = "{";
close_brace = "}";
semicolon = ";";
backtick = "`[^`]+`";
return_word = "return";
# string = "\"[^\"]*\""; # TODO

# literals = [word, equals, comma, open_paren, close_paren, open_brace, close_brace, semicolon, backtick, return_word, string];
literals = [word, equals, comma, open_paren, close_paren, open_brace, close_brace, semicolon, backtick, return_word];

zeroOrMore = (grammar) {
    return grammar;
};

each = (arg1, arg2) {
    return 3; # TODO
};

statement = () {
    defn = () {
    };
};

statement_with_semi = () {
    defn = () {
        return each(statement, semicolon);
    };
};

statements = () {
    defn = () {
        return zeroOrMore(statement_with_semi);
    };
};

program = () {
    defn = () {
        return statements;
    };

    tocode = () {
        return ".global main\nmain:\n";
    };
};

tocode = (ast) {
};

parse = (grammar) {
    grammar = grammar();
    defn = grammar.defn();
    return parse(defn);
};

make_assembly = (infile) {
    infile_contents = read_file(infile);
    parse_tree = parse(program);
    return tocode(parse_tree);
};

write_executable = (assembly, outfile) {
    # Invoke gcc to assemble
    `gcc -x assembler -o {outfile} -`(assembly);
};

assembly = make_assembly(infile);
write_executable(assembly, outfile);
